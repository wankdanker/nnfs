const X = [
    [0, 0],
    [0, 1],
    [1, 0],
    [1, 1]
]

const T = [
    0,
    1,
    1,
    1
]

class LayerDense {
    constructor(inputs, neurons) {
        this.weights = mArray([inputs, neurons], () => Math.random())
        this.biases = mArray([neurons], () => 0)
    }

    forward(inputs) {
        //manually added (missed by gpt4)
        this.lastInput = inputs
        this.output = sum(dot(inputs, this.weights), this.biases)
    }

    //generated by gpt4
    backward(dOut) {
        this.dWeights = dot(transpose(this.lastInput), dOut);
        this.dBiases = dOut.reduce((sum, row) => sum.map((x, i) => x + row[i]), new Array(this.biases.length).fill(0));
        this.dInput = dot(dOut, transpose(this.weights));
    }
}

//gpt4 rewrote this
class ActivationReLU {
    forward(inputs) {
        this.inputs = inputs;
        this.output = max(0, inputs);
    }

    derivative(x) {
        // Relu Derivative is 1 for x > 0 and 0 for x <= 0
        return x > 0 ? 1 : 0;
    }

    backward(dOut) {
        this.dInput = dOut.map((row, i) =>
            row.map((val, j) => val * this.derivative(this.inputs[i][j]))
        );
    }
}
// class ActivationReLU {
//     forward(inputs) {
//         this.inputs = inputs
//         this.output = max(0, inputs)
//     }

//     derivative(x) {
//         // Relu Derivative is 1 for x >= 0 and 0 for x < 0
//         return x >= 0 ? 1 : 0
//     }
//     backward(dOut) {
//         this.dInput = dOut.map((row, i) =>
//             row.map((val, j) => val * this.derivative(this.inputs[i][j]))
//         );
//     }
// }

//added by gpt4
class ActivationSigmoid {
    forward(inputs) {
        this.output = inputs.map(row => row.map(val => 1 / (1 + Math.exp(-val))));
    }

    derivative(x) {
        return x * (1 - x);
    }

    backward(dOut) {
        this.dInput = dOut.map((row, i) => row.map((val, j) => val * this.derivative(this.output[i][j])));
    }
}

// console.log(mArray([4, 3], () => Math.random()))
// console.log(new LayerDense(4, 3))

const layer1 = new LayerDense(2, 4)
const layer2 = new LayerDense(4, 1)
// const layer3 = new LayerDense(16, 1)
const activation1 = new ActivationReLU()
const activation2 = new ActivationReLU();

// layer1.forward(X)
// activation1.forward(layer1.output)
// // console.log(activation1.output)
// layer2.forward(activation1.output)
// activation2.forward(layer2.output)
// console.log(activation2.output)

// let error = 0
// for (let x = 0; x < activation2.output.length; x += 1) {
//     error += Math.pow(T[x] - activation2.output[x], 2) * .5
// }
// console.log(error)



// Training parameters
const epochs = 10000;
const learningRate = 0.1;

// Train the network
for (let epoch = 0; epoch < epochs; epoch++) {
    // Forward pass
    layer1.forward(X);
    activation1.forward(layer1.output);
    layer2.forward(activation1.output);
    activation2.forward(layer2.output);

    // Calculate error
    let error = 0;
    for (let x = 0; x < activation2.output.length; x += 1) {
        error += Math.pow(T[x] - activation2.output[x], 2) * 0.5;
    }

    // Backward pass
    let dOut = activation2.output.map((row, i) => row.map(val => val - T[i]));
    activation2.backward(dOut);
    layer2.backward(activation2.dInput);
    activation1.backward(layer2.dInput);
    layer1.backward(activation1.dInput);

    // Update weights and biases
    layer1.weights = layer1.weights.map((row, i) => row.map((val, j) => val - learningRate * layer1.dWeights[i][j]));
    layer1.biases = layer1.biases.map((val, i) => val - learningRate * layer1.dBiases[i]);
    layer2.weights = layer2.weights.map((row, i) => row.map((val, j) => val - learningRate * layer2.dWeights[i][j]));
    layer2.biases = layer2.biases.map((val, i) => val - learningRate * layer2.dBiases[i]);

    // Print error every 100 epochs
    if (epoch % 1000 === 0) {
        console.log(`Epoch ${epoch}, Error: ${error}`);
    }
}

// Test the network
layer1.forward(X);
activation1.forward(layer1.output);
layer2.forward(activation1.output);
activation2.forward(layer2.output);
console.log("Output after training:");
console.log(activation2.output.map(r => r.map(Math.round)));

// console.log(layer1.weights, layer1.biases)



function dot(m1, m2) {
    //TODO: check matching shape
    const s1 = shape(m1)
    const s2 = shape(m2)

    let result = new Array(m1.length).fill(null).map(() => new Array(m2[0].length).fill(0))

    for (let i = 0; i < m1.length; i += 1) {
        for (let j = 0; j < m1[0].length; j += 1) {
            for (let k = 0; k < m2[0].length; k += 1) {
                result[i][k] += m1[i][j] * m2[j][k]
            }
        }
    }

    return result
}

/**
 *
 *
 * @param {number[]} shape
 * @param {function} fill
 * @return {Array} 
 */
function mArray(shape, fill) {
    //copy the shape array
    shape = shape.slice()

    const count = shape.shift()

    if (!count) {
        return fill()
    }

    const current = new Array(count)

    for (let x = 0; x < count; x += 1) {
        current[x] = mArray(shape, fill)
    }

    return current
}

function sum(a1, a2) {
    //TODO: check shape
    const s1 = shape(a1)
    const s2 = shape(a2)

    let sums = new Array(a1.length).fill(null).map(() => new Array(a1[0].length).fill(0))

    for (let i = 0; i < a1.length; i += 1) {
        for (let j = 0; j < a1[0].length; j += 1) {
            sums[i][j] = a1[i][j] + a2[j]
        }
    }

    return sums
}

// console.log(max(0, [-1, 2, 5, -3]))
// console.log(max(0, [[-1], [2], [5], [-3]]))
// console.log(max(0, [[[-1]], [[2]], [[5]], [[-3]]]))
function max(val, m1) {
    let result = []

    for (const a of m1) {
        if (Array.isArray(a)) {
            result.push(max(val, a))
        }
        else {
            result.push(Math.max(val, a))
        }
    }

    return result
}

function transpose(m1) {
    const rows = m1[0].length
    const columns = m1.length

    const m2 = new Array(rows).fill(null).map(() => new Array(columns))

    for (let i = 0; i < columns; i += 1) {
        for (let j = 0; j < rows; j += 1) {
            m2[j][i] = m1[i][j]
        }
    }

    return m2
}

function shape(m1) {
    const lengths = []
    let current = m1

    while (Array.isArray(current)) {
        lengths.push(current.length)
        current = current[0]
    }

    return lengths
}